* Modeling the Corporation

** Prerequisites
To understand this document you should be familiar with object-oriented programming and domain modeling.

See:
- http://martinfowler.com/eaaCatalog/domainModel.html
- http://www.martinfowler.com/bliki/AnemicDomainModel.html
** Misc Thoughts
In the financial services industry, UML and XML models for financial transactions exist: ISO 20022 is the basis for SWIFT.

Maybe we can import some of those ideas. A startup investment is, after all, just a special case of a financial transaction.

Corporations are relatively lightweight structures, especially at the startup stage. Even public corporations aren't terribly complex: they have a lot of shareholders, a few directors, and a bunch of bank accounts.

Astonishingly, we have not been able to find a data model schema for a corporation. So here's one.
** Entities
*** Primary Entity: Company

The Models given in this document claim to work for two kinds of primary entities. A Company is assumed to be one of the following:

**** Private Limited Companies                                              :SG:SG_CA50_20160103:

The Resolutions Model claims correctness for Singapore Private Limited Companies.

**** Exempt Private Limited Companies                                       :SG:SG_CA50_20160103:

For the purpose of the Resolutions Model, all facts true of Private Limited Companies are also true of Exempt Private Limited Companies.

*** Secondary Entities                                                                   :general:

Along the way, the following secondary entities will turn up:

**** Natural Person                                                                     :general:

Usually a human being. May be resident in any jurisdiction.

May be the estate, personal representative, attorney, etc, of a human being.

**** Organization                                                                       :general:

Synonymous with a corporate person -- anything that is not a natural person. For example, an investment holding company may be a corporate shareholder.

*** Roles

The following roles exist with-respect-to the Company.

**** General Role Attributes
a role relationship starts and stops in time. So we need [[https://en.wikipedia.org/wiki/Bitemporal_data][bitemporality]].

**** Director Role                                                                      :general:

**** Shareholder Role                                                                   :general:

May be of a specific class of shares.

**** Bondholder Role                                                                    :general:

Of a specific security.

**** Warrantholder Role                                                                 :general:

Of a specific security.

**** Investor Role                                                                      :general:

**** Member Role                                                            :SG:SG_CA50_20160103:

Often synonymous with shareholder, but specifically defined as a person entitled to receive notices of meetings.

Not tagged as global because the notion of a member may not be common outside Singapore jurisdiction.

*** Entities Out of Scope                                                                :general:

The resolution model does not claim to cover:

**** Companies Limited by Guarantee
**** Trusts
**** Public Companies



* Modeling the Drafting -- Semantics
Within a contract, we deal with terms and content. This model cares about the conceptual/abstract representation, also known as the formal representation. It also cares about the physical text in a natural language. The physical text may include formatting instructions.

** Background Reading
To understand this section, you should:
- be reading Ken Adams, A Manual of Style for Contract Drafting
- understand what a context-free grammar is, and be familiar with Backus-Naur Form
- read https://drive.google.com/open?id=0BxOaYa8pqqSwTC04OTF5b1hYams Some computational properties of a model for electronic documents, TBC 1989
- view https://drive.google.com/open?id=0BxOaYa8pqqSwUWlCajFJQURXdG8 introducing deontic logics, Gorin 2010
- read [[https://www.um.edu.mt/__data/assets/pdf_file/0008/51749/wict08_submission_17.pdf][conflict analysis of deontic contracts, Stephen Fenech]]
- read [[http://www.diku.dk/~paba/pubs/talks/bahr15icfp.html][Certified Symbolic Management of Financial Multi-party Contracts]]
- read http://wyner.info/research/Papers/2014/NL_DeonticConcepts_Lux_2014.pdf another perspective on deontic logic
- read http://wyner.info/research/Papers/WynerPetersJURIX2011.pdf -- Wyner 2011, /On Rule Extraction from Regulations/
- read http://wyner.info/research/Papers/2013/WynerICAIL2013Tutorial.pdf discussing text extraction
- http://people.dsv.su.se/~petia/Publications/lap98.pdf shows how to model deontics for software specifications, in software

Video
- watch Surden's [[https://www.youtube.com/watch?v=KLAE_SKMeAY&index=61&list=PL48E61C121CAD0E1B][2011 talk on Computable Contracts]]
- watch the Futurelaw [2013-04-26 Fri] [[https://www.youtube.com/watch?v=KBI8_tv2VDM][presentation on Computational Law and Contracts]]
- watch the FutureLaw [2016-04-30 Sat] [[https://www.youtube.com/watch?v=efr9VctcMe8&index=1&list=LLprx0R928jz7WPTG5EBdrnQ][panel discussion: New Breakthroughs in Computational Law]]

Previous Legal DSLs:
- read Tom Hvitved's [[http://www.diku.dk/forskning/phd-studiet/phd/davidg_thesis.pdf/hvitved12phd.pdf][PhD Thesis]] which covers some of the most recent work in the field
- read https://drive.google.com/a/legalese.io/file/d/0BxOaYa8pqqSwWk9NallEck83T2M/view -- CLAN 2009
- read https://drive.google.com/a/legalese.io/file/d/0BxOaYa8pqqSwSjRMeGtzVGhIaWs/view -- FormaLex 2011
- read http://wyner.info/research/Papers/2013/OASISLegalRuleML.pdf on LegalRuleML.
- review [[https://www.lexifi.com/product/technology/contract-description-language][LexiFi's Contract Description Language]], MLFi
- review [[https://github.com/mpoulshock/HammurabiProject/blob/master/Code/DSL/DSL.pdf][Hammurabi's DSL]]
- review the DSL presented in Hvitved's [[http://www.diku.dk/forskning/phd-studiet/phd/davidg_thesis.pdf/hvitved12phd.pdf][PhD Thesis]], particularly Appendix E.2.3


** Formal Representation

Formally, a legal document obeys a grammar. In this document, we treat "grammar" and "schema" as [[https://www.w3.org/People/Bos/Schema/schemas][rough homomorphisms]], with schemas being slightly more specific and grammars being slightly more general.

Different jurisdictions may impose different schemas. For example, a contract written in the US style will look different from a contract written in the UK style. However, both documents will exhibit a high degree of structure. A family of UK documents will share the same schema.

A rough schema for a contract could be: title, date, parties, recitals, definitions, conditions precedent, habendum, standard bits, attestation. The habendum is composed of a list of clauses.

A rough schema for a directors' resolution could be: letterhead, item [...], signatures. Each item is either a Resolved or a Noted.

** Regulations and Contracts as Business Logic

Our approach departs from the prior art in a key way: we treat contract formalization not as a problem in linguistics, but as a problem in business logic modeling. Rather than parse contracts into structured syntax trees, we formalize contracts as executable programs. Programs, of course, may themselves be modeled as digraphs. Still, the goal is to represent the semantics of the contract first, and the syntax second.

What does that mean?

Let's take [[http://www.accessdata.fda.gov/scripts/cdrh/cfdocs/cfcfr/CFRSearch.cfm?FR=610.40][an example of regulatory verbiage]] which was the subject of a paper ([[http://wyner.info/research/Papers/2013/WynerICAIL2013Tutorial.pdf][with slides]]) by Peters & Wyner ([[https://legalinformatics.wordpress.com/2011/11/11/wyner-and-peters-on-rule-extraction-from-regulations/][blog post]], [[http://wyner.info/research/Papers/2014/NL_DeonticConcepts_Lux_2014.pdf][more slides on deontics]]):

#+BEGIN_QUOTE
Except as specified in paragraph c, you, an establishment that collects blood, must test each donation of human blood that is intended for use in preparing a product for evidence of infection due to the following communicable disease agents:
(1) Human immunodeficiency virus, type 1;
(2) Human T-lymphotropic virus, type I, and
(3) Human T-lymphotropic virus, type II.
#+END_QUOTE

*** As a Syntax Tree
The linguistic approach parses the syntax (rightly or wrongly) as follows:
#+BEGIN_SRC xml
    <ExceptionClause2>Except as <Verb>specified</Verb> in paragraph c</ExceptionClause2>,
    <AgentNP>you, an establishment that <Verb>collects</Verb> blood,</AgentNP>
    <Obligation>must</Obligation> <Verb>test</Verb>
    <ThemeNP>each donation of human blood that
    <Passive><Verb>is</Verb><Verb>intended</Verb></Passive> for use in preparing a product
    for evidence of infection due to the following communicable disease agents</ThemeNP>:
#+END_SRC

It is, fundamentally, sentence diagramming, with some wiring up of pronouns to agents.

*** As Javascript
A computational contract would represent the same text very differently. The following object-oriented code represents each agent in the sentence with its own constructor, attributes, and methods:
#+BEGIN_SRC js
  // This code uses syntax based on the Joose.it metaprogramming framework for Javascript.
  // It should make sense to any programmer versed in the object-oriented paradigm.
  Role('bloodCollectingEstablishment', {
    has: {
      communicableDiseaseAgentsToTest : {
        is : 'rw',
        init : [ "Human immunodeficiency virus, type 1",
                 "Human T-lymphotropic virus, type I",
                 "Human T-lymphotropic virus, type II" ] },
      bloodDonations : { is : 'rw', init: [ ], isPrivate: true },
      // Array of BloodDonation objects. This includes both clean and infected blood,
      // so we limit access to specialized getter methods which should prevent
      // unintentional retrieval of infected blood.
      // Such methods include getCleanDonations() and getInfectedDonations(), not shown due to space limitations.
      // They filter through the bloodDonations list, inspecting bloodDonation.testResults.
    }
    methods: {
      bloodTestException : function(donation) {
        return (new Moon).getPhase() == "waxing crescent" || 
        donation != undefined && donation.getBloodType() == "O";
        }
      },
      collectBlood : function(donation) {
        this._initializeRelationWith(donation);
        this.bloodDonations.push(donation);
        // note that we always add the donation to the list of donations
        // without regard to whether it passed or failed the communicable-disease tests.
      },
      _initializeRelationWith : function(donation) {
        if (! this.bloodTestException(donation)) {
          if (donation.getUsageIntent().match(/for use in preparing a product/)) {
            this.getCommunicableDiseaseAgentsToTest().map(
              function(t) { donation.sendBloodTest(t); });
          }
        }
      },
      getBloodDonations : { return "ERROR: getter restricted for safety reasons. Please use getCleanDonations(), getInfectedDonations(), or getUntestedDonations instead to make your intent clear." }
      setCommunicableDiseaseAgentsToTest : function(tests) {
        // in case the list of communicable disease agents changes, reschedule all donated blood for re-testing against newly introduced tests.
        // not shown for space reasons
      },
    }
  });

  Class('BloodDonation', {
    has: {
      testResults : { is: 'rw', init: {} },
      bloodType:    { is: 'rw' }, // one of A, B, O, AB
      usageIntent:  { is: 'rw' },
      collectedBy:  { is: 'ro', isa: 'bloodCollectingEstablishment' }
    },
    methods: {
      sendBloodTest: function(testName) {
        this.testResults[testName] = undefined;
        // Submit a blood sample for testing against testName.
        // When the result arrives, it triggers the method recvBloodtest(testName).
      },
      recvBloodTest: function(testName, result) {
        this.testResults[testName] = result;
      },
      setUsageIntent: function(intent) { // in case the usage intent for the blood changes after we've collected it
        this.usageIntent = intent;
        this.getCollectedBy()._initializeRelationWith(this);
      }
    },
    after : {
      initialize: function() {
        this.sendBloodTest("type"); // always test for blood type, as required by bloodCollectingEstablishment.bloodTestException().
      }
    },
  });
#+END_SRC

Javascript was chosen for the above formalization because it is familiar to many programmers.

*** As Prolog
The equivalent program in a logic programming language:

#+BEGIN_SRC prolog
  regulation([title(21), volume(7), section([610,40,a])],
             Subject, Scenario, Object, excepted ) :-
      establishment(Subject), collects_blood(Subject),
      Scenario = blood_collection, for_production(Subject, Object),
      exception(Subject, Scenario, Object).

  regulation([title(21), volume(7), section([610,40,a])],
             Subject, Scenario, Object, pass ) :-
      establishment(Subject), collects_blood(Subject),
      Scenario = blood_collection, for_production(Subject, Object),
      communicableDiseaseTests(Object).

  for_production(Subject, Donation) :-
      blood_collected_by(Subject, Donation),
      member("for use in preparing a product", Donation.intent).

  communicableDiseaseTests(Donation) :-
      member("Human immunodeficiency virus, type 1", Donation.tests),
      member("Human T-lymphotropic virus, type I",   Donation.tests),
      member("Human T-lymphotropic virus, type II",  Donation.tests).

  exception(_, blood_collection, Donation) :- Donation.bloodType = "O".
  exception(_, blood_collection, _       ) :- moonphase(waxing_crescent).
  moonphase(waning_gibbous).

  establishment(chopshop).
  collects_blood(chopshop).

  blood_collected_by(chopshop,
                     donation{ date:date(2015,1,1),
                               name:"first donation",
                               intent:["for use in preparing a product"],
                               tests:[
                                   "Human immunodeficiency virus, type 1",
                                   "Human T-lymphotropic virus, type I",
                                   "Human T-lymphotropic virus, type II",
                                   "bloodType"
                               ],
                               bloodType:"A" }).
#+END_SRC

The code is much shorter and expressive of the intent of the regulation, at the cost of procedural operability.

*** In Legalese

In the Legalese Domain-Specific Language, we strike a balance between executability and output to natural language:

#+BEGIN_SRC text
  entity e has bloodDonations [{}] ("donation of human blood")
  rule bloodCollection governs e ("you") being { .is?(establishment) that .does?(collectsBlood) } {
    dealswith .bloodDonations
 
    except (moonphaseException) {
      e.must ("Contagious Disease Test Requirement") {
        foreach bd in .bloodDonations that { .isForProduction? } {
            e.must.bloodTest ("test _O_ for evidence of infection due to :-e.CDA-:") {
                O:bd against e.CDA.all }
        }
      }
    }
    
    definitions:
      bd.isForProduction? ("is intended") = {
         bd.intents.contains("for use in preparing a product"
                             INCLUDING ("as a component of" OR "used to prepare") -> "a medical device")
      }
      e.CDA ("communicable disease agents") = ["HIV 1", "HTLV 1", "HTLV 2"]
  }

  exception moonphaseException (rule) {
      return (moon.phase == "waxing crescent")
  }

  exception moonphaseException ( [rule, e.must, bd] ) { // rules have parameter type & arity match. this specifies a certain subtree of the code path.
      return (bd.bloodType == "O")
  }
#+END_SRC

To output to French instead of English, we instruct Legalese with a basic mapping:

#+BEGIN_SRC text
  lingua en_to_fr {
      you: vous / toi / tu
      donation of human blood: don de sang humain
      test _O_ for evidence of infection due to: _O_ examiner des preuves de l'infection due à
      communicable disease agents: agents de maladies transmissibles
      is intended: est destiné
      for use in preparing a product: pour une utilisation dans la préparation d'un produit
      as a component of: en tant que composant de
      or: ou
      used to prepare: utilisée pour préparer
      a medical device: un dispositif médical
      all: tous
  }
#+END_SRC


** Some thoughts about the DSL

*** Background and Resources for building a DSL

**** http://martinfowler.com/dsl.html
**** http://www.martinfowler.com/articles/languageWorkbench.html
**** https://www.jetbrains.com/mps/

*** Primitives from Patterns
One strategy for designing a DSL is to compile a list of common patterns in the domain itself; then construct a set of primitives that make it possible to express those patterns in a formal, unambiguous, machine-readable form.

That form should be approximately as compact as the original text.

If the formal version is longer than the original text, that diffuseness should arise from the desire for unambiguous specification.

If the formal version is shorter than the original, that terseness should arise from the correct application of mathematical and programming concepts like modularity, abstraction, encapsulation, and recursion.

*** Recognizing existing concepts from legal drafting
Legal drafting already adumbrates a number of concepts which we can translate to our domain..

For example, one pattern pair described by Jon Bing in "Let there be LITE" is the principle of textual replacement vs omnibus replacement. (History of Legal Informatics, Paliwala, p.24)

**** How would textual replacement appear in the DSL?

Textural replacement transforms the text.

**** How would omnibus replacement appear in the DSL?

Omnibus replacement transforms the interpretation.

*** Some Cognitive Dimensions
https://en.wikipedia.org/wiki/Cognitive_dimensions_of_notations

*** A Blue-Sky Wild-Eyed Suggestion: Subjective Perspectives

Maybe the fundamental principle of this language is the representation -- just as the fundamental premise of Clojure is the sequence, or the fundamental premise of Erlang is the message-passing actor, or the fundamental premise of Elm is the signal, or the fundamental innovation of Unix is the pipeline.

What is a representation?

The Legalese DSL is functional.

The Legalese DSL is also transactional: every object contains a history of how it came to be that way. Fowler, as usual, is ahead of us: he calls this the [[http://martinfowler.com/eaaDev/EventSourcing.html][Event Sourcing model]].

A presentation is a pattern-match against any object or pattern of objects which satisfies a predicate. A representation may alter the matched presentation.

In the trivial case a representation passes thru the original presentation, with only two addenda: the business tag and the system tag, indicating that the representation acted to filter the presentation. This vocabulary alludes to bitemporality. There may be cases where a representation insists that it should not be logged, in which case we omit the business tag but leave in the system tag.

Representation has to be as cheap in Legalese as tail recursion is in Lisp, or as method chaining is in an object-oriented language.

Perhaps an "imputation" would be as good a word as "representation".

Every pattern represented includes the following properties:
- imputer :: this identifies the code that originates the representation. It could be a clause in a regulation or contract.

**** Examples



**** Allusion

Note: We allude to legal usages of "representation":
- know all men by these presents
- a lawyer represents a client
- a party to a contract makes representations
- a litigator makes a presentation of a 

*** Functionality

The strongly functional ideas of referential transparency and purity should help in drafting contracts.

*** Modularity
One obvious place where they help: a drafter can choose the degree of modularity: they can subscribe so adamantly to Don't Repeat Yourself that the code ends up being obfuscated; or they can "unroll the loop" so much that a reader will be constantly flipping between pages just to see if the definitions have stayed the same.

*** Versioning and Representaiton

In Clojure, Software Transactional Memory provides transactional integrity for variable references. This is a lot like locking in a database, or rollback transactions.

In a bitemporal database, every fact is inflected with its valid time and system time.

Now think of git as a huge ledger in a DAG that represents commits as transactions.

Why not take STM to the next level, with fully versioned variables?

In Legalese, Variable Versioning records the "varying" value of "variables" across representations.

In the Legalese DSL, every fact resides in a database, or ledger, which is constructed on the fly from the Premises. The database as a whole is mutable, in the same way that Prolog's database is mutable through assertions and retractions, or a git repository is mutable through commits. However, individual facts in the database are immutable. They are the equivalent of scala's vals as opposed to vars.

Variables are immutable; to mutate a variable, represent it. It then becomes the master HEAD.

Yes, that means that representations grow as a DAG, just as a git repository is a DAG.

*** Time and Space as Organizing Principles

What is time? "The universe's way of keeping everything from happening at once." -- Sandman

*** A specification language first, and an implementation language second

Regulations are specifications.

What about contracts?

Is a contract a program? Or the specification for a program? Or a program that validates past execution?

Maybe the DSL will need to support all of the above notions.

The DSL expresses constraints and deontics.

From the DSL it should be possible to evaluate a given scenario; the evaluation should return the status of compliance with deontics, the description of penalties, and the status of the contract generally: breach / voidable / void / performed / part performed. In that sense a contract is a specification.

From the DSL it should also be possible to derive operable expressions from a party perspective -- for example, a security should offer triggers and handlers as callbacks which can be run against any future issue, or event, or scenario, or time. So in that sense a contract is a program.

See also [[https://en.wikipedia.org/wiki/Formal_specification][wikipedia:"Formal specification"]]


*** Multiparadigm Support

In [[http://www.amazon.com/Multi-Paradigm-Design-James-O-Coplien/dp/0201824671]["Multi-paradigm Design for C++"]] James Coplien describes how C++ supports multiple paradigms: classes, overloaded functions, templates, modules, ordinary procedural programming, and others.

The patterns of lay legal contracts likewise span multiple paradigms: some more imperative, some are more declarative. Some describe state transitions on a core object or objects, with or without human input.

#+BEGIN_QUOTE
It would indeed be nice if some single logical language, with a single axiomatic base, were to satisfy all our needs, because then we could set about providing a tool kit of programs to assist designers in using this single calculus. [...]

The different branches of mathematics are too various, and our linguistic invention too fertile for this kind of uniformity to be sustained. The subject matter of computation is equally various, so we would expect the same need for plurality; indeed Kim Larsen and I recently did a small experiment in process validation and found that, in the space of three or four pages, we needed three or four distinct formal calculi to express the natural proof succinctly.

Robin Milner, /Is Computing an Experimental Science?/
#+END_QUOTE

To fit the domain, the DSL will have to allow multi-paradigm drafting.

*** Implications for Reverse Engineering
As we start to port lay contracts over, one principle that will aid drafting is to identify the dominant paradigm in each chunk of the "code".

*** Homoiconicity Squared

In homoiconic languages like Lisp, "code is data".

In Legalese, "code execution is data" too -- the history of every computation is available. If we want to know how something got to be the way it is, we can trace current and past state.

*** Compile time versus run time

UPPERCASE keywords run at compile time and help construct the text of the contract.

lowercase keywords are the meat of the contract itself.

in C, think #ifdef vs if()

in our case we would have `IF()` vs `if()`

** Legal Formalization: a Brief Overview

In an application, "business rules" and "business logic" are typically encoded in machine-executable form by a domain expert. Sometimes, DSLs are employed.

In the legal domain, we consider such business rules and logic to take two forms: regulatory constraints; and legal agreements and other resolutions. For short, we call these "public" and "private" respectively.

The public rules impose constraints on parties -- /involuntary/ deontics.

The private rules express constraints undertaken by parties -- /voluntary/ deontics -- and performative statements -- "we hereby do something", or "we warrant that...".

These public and private logics interact constantly. For example, if a corporation performs action A by executing paperwork P, then a legally mandated filing F must be performed by date D else the corporation will be subject to penalties. A and P are private. F and D are public.

The academic literature has explored the formalization of regulations, typically in the form of XML syntax or linguistic parse trees.

The academic literature has explored the automation of the formalization of regulations, using software like GATE.

At least one commercial effort, acquired by Oracle as [[https://redstack.wordpress.com/2010/08/03/creating-rules-in-oracle-policy-automation/][Oracle Policy Automation]] has resulted in an expert system [[https://en.wikipedia.org/wiki/Business_rule_management_system][BRMS]] which parses structured natural language and builds a query wizard.

The research community has begun to explore the formalization of private contracts -- "computable contracts" or "smart contracts" -- which express the semantics of a contract in a form executable by machine. The crucial distinction between a program expressing business logic, and a computable or smart contract, is that the contract itself, as a program, is granted executive agency, in the same way that a power of attorney might be granted to a third party, and, once invoked, is capable of effecting changes in the real world. Furthermore, the language in which a smart contract is written must be rich enough to express general computation, and not overly limited to specific domains.

** Novelties
The research community is only just beginning to explore the generation of natural-language contracts from a formalism. At present, no software is capable of converting the formalization of the example above into a natural language. We claim that such a compiler is possible.

The literature also has not explored the automated generation of private logics from public logics, as an exercise in constraint satisfaction. At present, a domain expert is required to encode such business logic. We seek to advance the state of the art from syntax to semantics, and to automate the process.

At present, once business logic is encoded into an application, that logic is executed by machine, but the whys and wherefores that led to a particular outcome are often obscure. Our project will explain the rationale for any highlighted component.

** Primitives and Principles


*** requirements principles
**** entities are modelled using objects / types

Elements belong to sets.

#+BEGIN_QUOTE
This agreement is between A, B, C (the "Alphas"), 1, 2, (the "Numbers"), and #! (the "Punct"), collectively the "Parties".
#+END_QUOTE

Elements can join and leave sets.

#+BEGIN_QUOTE
The New Investors hereby accede to and ratify the Previous Agreement, and agree to be bound by the terms and conditions of the Previous Agreement as if they had been a party thereto, and to duly and punctually perform and discharge all liabilities and obligations whatsoever from time to time to be performed or discharged by it under or by virtue of the Previous Agreement in all respects as if named as a party therein.
#+END_QUOTE

**** relations are modelled using objects / types

A share is a relation between a Company and a Shareholder, with certain attributes, such as issue price, voting rights, convertibility, etc.

**** a relation can be created, modified, or terminated by an agreement

an investment agreement creates a shareholder relation.

#+BEGIN_QUOTE
Each investor listed as a "Purchaser" on Schedule 1 (each, a "Purchaser") shall purchase at the applicable Closing and the Company agrees to sell and issue to each Purchaser at such Closing that number of shares of Series Seed Preferred Stock of the Company ("Series Seed Preferred Stock") set forth opposite such Purchaser's name on Schedule 1, at a purchase price per share equal to the Purchase Price.
#+END_QUOTE

an employment agreement creates an employer--employee relation.

a volunteer agreement creates an unpaid employee relation.

a nondisclosure agreement creates an NDA relation.

**** functional -- representations

A term in an expression may be functional in nature, in the sense that it depends on many other terms, each of which may be depend on other terms.

method share.conversion_price = least_of(antidilution_price, discount_price, valuation_cap)

**** actor / reactor model

both entities and relations are expected to respond to scenarios by emitting transformations.

**** language-orientation

a compiler generates an isomorphic natural language representation of programs written in the DSL.

**** homoiconicity

a program may modify itself:

#+BEGIN_QUOTE
Except where the context otherwise requires, references to any person include its successors and permitted assignees. Except where the context otherwise requires, Clauses which refer to the "Company" shall apply mutatis mutandis to subsidiaries or successors of the Company which may from time to time be established.
#+END_QUOTE

**** traces, history, and state

a piece of code must be able to reason based on knowledge available at time of execution. It needs to know what actions have been taken by the program and all related entities to date. If those actions are available in a log, great. That log may need to contain a representation of the relevant objects at a different time.

So bitemporality applies to object state.

#+BEGIN_QUOTE
If the Company issues any additional shares (including, but not limited to, all classes of shares, warrants, rights to subscribe for shares and securities convertible into any share class) for a consideration per share that is less than the Subscription price per share (as adjusted for any change of nominal values of shares, e.g. share splits and similar events), the subscription price (as adjusted for share splits, consolidations of shares and similar events) of the subscribed shares issued subject to this Investment shall be adjusted on a full ratchet basis.
The adjustment will be made through the issuance of additional shares to the Subscriber at par value (i.e. S$1.00 per subscribed share of nominally S$1.00), so that the ownership of the Subscriber after the dilutive issuance shall be set equal to the ownership that the Subscriber would have had if the subscription price paid by the Subscriber (based on the Investment amount, added for the avoidance of doubt, the amount paid to Subscribe for the anti-dilution shares) had been the same as the price of the dilutive issuance.
#+END_QUOTE

**** temporal logic

The functions used to compute a term may finally depend on state which may have arisen and changed between the times of negotiation, execution, and eventuation.

**** deontic modal logic

A contract defines obligations.

Obligations may be violated; such violations may entail further obligations.

*** Agreements follow a Document Schema
*** Elements of Agreements: the Clause / Article / Section
*** The Definitions
*** Deontic Obligations
*** Exceptions
*** Mutatis Mutandis
*** Action Pursuant To
*** References
*** The Event
*** The Deemed Event

** Dimensions
There are many ways to represent a given clause. Some dimensions of interest are:

*** Formal vs Natural Language Representation

A concept may be expressed formally.

A concept may be expressed naturally, in a language like English.

A concept may be expressed in a hybrid of formal and natural -- see [[https://en.wikipedia.org/wiki/Controlled_natural_language][Controlled Natural Languages]], e.g. [[https://en.wikipedia.org/wiki/Attempto_Controlled_English][Attempto]].

*** Compactness vs Completeness

For compactness, we want to be able to summarize a clause as tersely as possible.

For completeness, we want to be able to expand a clause, to "look inside" it both syntactically and semantically.

*** Locality and Coupling

Some clauses are limited in scope. A standalone clause does not modify, and is not modified by, any other clause.

Other clauses are highly coupled. A coupled clause explicitly modifies, or is explicitly modified by, another clause.

** Modals
factive, non-factive, contrafactive, alethic, epistemic, temporal, deontic.  see p. 133 of wyner tutorial 2013.
** Distributed Deontics
A contract contains, among other things, a collection of deontic propositions (obligation, prohibition, permission). [[https://www.ietf.org/rfc/rfc2119.txt][RFC2119]] specifies the language "MUST", "MUST NOT", and "MAY" respectively.

These propositions can be seen as a shotgun-spray of agency and consequence: parties committing to do or not do things, and if this happens, then that follows.
** Conflict Resolution
*** Specificity
as with CSS, the most specific match wins.

scope of a rule.
** Event Handling

A clause contains one or more deontic statements that constrain the behaviour of the party or parties involved. We say that a party is /bound/ by contract.

This means that any time a party contemplates an action or inaction, that /event/ could be /evaluated/ against every contract that /binds/ the party. An event describes a scenario involving one or more parties.

This process of proposal evaluation operates much as you might imagine: each clause, or /proposition/, in the contract is /proposed/ the /event/, and /returns/ an opinion about whether the proposal passes or fails the proposition.

You may be familiar with the idea of a program executing on a virtual machine on some input data. In this case, the contract is the program, the proposal is the input, and the output is a pass/fail opinion.

In /introspection mode/, running a contract with a null proposal, and a party set, may return the obligations of the parties.

** Respect

Proposal evaluation occurs with respect to a given counterparty. In the context of a given proposition, a given counterparty may not care about a given actor's event.

** Defactorization

Natural language contracts often "unroll the loop", exposing a huge chunk of code inline. When another caller wants to refer to the same code, that caller often simply refers to the code and defines deltas. Programming patterns like refactoring, modularization, and parameterization are beyond the capabilities of natural language programmers, but are available to formalizations.

If function definitions are unavailable under the "coding style" of the natural language legal forms, then we must mimic the bad practice.

Some call this antipattern "defactoring" or "obfuscation" -- deliberately reducing abstraction.

** Pattern Matching Mutation

As with Lisp and other strongly homoiconic languages, we expose the syntax tree to itself.

This means, if we define a rule:

#+BEGIN_SRC text
  entity hotel has toilets ("toilets")
  rule toilets governs hotel ("Restroom Requirements") {
      dealswith .workingToilets = .toilets.filter(t){t.working == true} ("working toilets")
      val numMaleToilets   ("the number of working male toilets")   = hotel.workingToilets.count(t){t.gender == "m"}
      val numFemaleToilets ("the number of working female toilets") = hotel.workingToilets.count(t){t.gender == "f"}
      val numUnisexToilets ("the number of working unisex toilets") = hotel.workingToilets.count(t){t.gender == "u"}
      hotel.must ("the Flushagette Rule") {
        (numUnisexToilets + numFemaleToilets) >= numMaleToilets
      }
      hotel.mustnot ("the Rosa Parks Rule") {
        hotel.toilets.count(t){ t.has?("race") }
      }
  }
#+END_SRC

We can clone and modify that rule, /mutatis mutandis/:

#+BEGIN_SRC text
  entity hotel has babyrooms ("baby changing stations")
  rule babyrooms governs hotel = mutatis(hotel.rule(toilets),babyrooms)
#+END_SRC text

Which means, the same rule shall apply to baby changing stations, mutatis mutandis.

Languages like Io and ReFLect make this sort of thing very natural.

** Examples Under Construction
*** Contract-Level Examples
**** Example 1A: definition
#+NAME: 1A round definition series seed
#+BEGIN_SRC js
  var investment = newRound( {
    security: "SeriesSeed",
    parties: {
      company: "MyCompany",
      new_investors: [ { name: "Alice", commitment: 100000 },
                       { name: "Bob",   commitment:  50000 },
                       { name: "Carol", commitment:  20000 } ] },
    terms: {
      pre_money_valuation: 10000000,
      round_size:           1000000,
      esop:                      15
    }
  } );
#+END_SRC

This is the formal representation defining a simple Series Seed investment round. The meat of the definition is your basic JSON data structure, which could be constructed by a UI or read out of a spreadsheet.

**** Example 1B: export to natural language
#+NAME: 1B export natural
#+BEGIN_SRC js
investment.workflows().export_as({format:"XML", lang:"en-US"});
#+END_SRC

This outputs all the paperwork required to effect the round, in XML format, suitable for import into InDesign and subsequent output to PDF.

In practice the workflows() method runs prerequisites(), agreements(), and filings().

**** Example 1C: export to formal representation
#+NAME: 1C export formal
#+BEGIN_SRC js
investment.agreements("shareholder").export_as(format:"javascript");
#+END_SRC

produces a bunch of Javascript. See the next example for a microscopic view of the clause-level exports.

*** Clause-Level Examples

The Series Seed v3.2 Certificate of Incorporation contains a clause:

#+BEGIN_QUOTE
Mandatory Conversion. Upon either (a) the closing of the sale of shares of Common Stock to the public in a firm-commitment underwritten public offering pursuant to a prospectus filed under the Securities and Futures Act or (b) the date and time, or the occurrence of an event, specified by vote or written consent of the Requisite Holders at the time of such vote or consent, voting as a single class on an as-converted basis (the time of such closing or the date and time specified or the time of the event specified in such vote or written consent,the <b><i>“Mandatory Conversion Time”</i></b>), (i) all outstanding shares of Series Seed Preferred Stock will automatically convert into shares of Common Stock, at the applicable ratio described in Section <xref to="conversionratio" /> as the same may be adjusted from time to time in accordance with Section <xref to="conversion" /> and (ii) such shares may not be reissued by the Company.
#+END_QUOTE

In this example, we'll see how Legalese represents that clause. In particular, we are interested in how the formal representation affords natural language generation.

**** Exposition in Lay Terms

The Gentle Reader may not be familiar with the semantics of this clause. If you need help understanding the clause, read on.

The context: the Company's constitution defines a class of shares called "Series Seed". A class attribute is "mandatory conversion". This clause describes when mandatory conversion can happen.

What does conversion mean? Series Seed shares turn into Common Stock.

What does mandatory conversion mean? That the conversion happens automatically, when some other condition is met. Neither the Company nor the Series Seed Holders can block the conversion.

What conditions trigger mandatory conversions? It turns out there are three possible triggers.

First trigger: there is an IPO -- an Initial Public Offering. Shares of the company are sold to the public in a public offering.

Second trigger: a certain voting majority of the Series Seed Holders agree to 

If any of these triggers occurs, then mandatory conversion follows.

**** Example 2A: Conversion
#+NAME: 2A conversion clause retrieval
#+BEGIN_SRC js
var clauses = investment.clauses_matching("conversion");
#+END_SRC

returns

#+NAME: 2B conversion clause content
#+BEGIN_SRC js
  [ { clauseName: { "en-US": "Mandatory Conversion" },
      handler: function(events) {
    for (var event_i in events) {
      var event = events[event_i];
      var parties = event.parties;
      var respect = event.respect; // party with deontic obligation perspective
      if (event.name == "IPO" ||
          event.name == "classVote") {
        var company = this;
      }
    }
      }
    } ]
#+END_SRC


**** Example 2B: 

* Modeling the Drafting -- Syntax
** Different styles
A given syntax may be styled in one or more ways. Different styles are possible. For example, one style might have the Signatures precede the Schedules; another might do it the other way.
** Singapore Contract Style
*** As a Prolog DCG
a BNF syntax would be an equivalent specification.

#+BEGIN_SRC prolog
  decorated_contract -->
      cover,
      contract.

  contract -->
      dated, sep0,
      between_parties, sep0,
      recitals, sep1,
      definitions, sep1,
      habendum, sep1,
      boilerplate, sep0,
      schedules, sep2,
      attestation, sep2,
      appendices.

  dated --> ['This',document,is,dated,Date],
            { contract_date(Date) }.

  between_parties --> ['Between', Parties],
                      { parties(Parties) }.

  recitals --> ['Whereas', Recitals],
               { recitals(Recitals) }.

  definitions --> [].
  habendum --> [].
  boilerplate --> [].
  schedules --> [].
  attestation --> testimonium, signatures.
  appendices --> [].

  testimonium --> [].
  signatures --> [].

  contract_date(Date(1,1,1901)).
  parties(['Alice', 'Bob', 'Charlie']).
  recitals(["Alice owes Bob money"]).

  sep2 --> [chapter_separator].
  sep1 --> [section_separator].
  sep0 --> [paragraph_separator].


    
#+END_SRC
** Adams Contract Style
http://www.amazon.com/Manual-Style-Contract-Drafting-ebook/dp/B00GUUQTZY/ is one bible
** Australian Style
Peter Butt's [[http://www.cambridge.org/au/academic/subjects/law/law-general-interest/modern-legal-drafting-guide-using-clearer-language-3rd-edition?format=PB&isbn=9781107607675][Modern Legal Drafting: A Guide to Using Clearer Language, 3rd Edition]]

* Modeling the Execution
the dependency and concurrency relationships between contracts and other documents, treating an individual document as a black box with just a blob of text and a bunch of signatures. it's the signatures we care about at this level.

* Modeling the Resolutions

This section records domain knowledge about corporate resolutions.

** Jurisdiction Scope -- Space

Domain facts which are generally true are tagged "general".

Domain facts which are specific to a particular jurisdiction are tagged accordingly.

** Jurisdiction Scope -- Time

Domain facts may be tagged with both application time and system time. Facts are true as of time of writing. System time may be found in Git.

Application time refers to the date that legislation/regulation comes into effect.

In the case of Singapore jurisdiction, Companies Act (Cap. 50) was last revved & effective as of [2016-01-03 Sun]. Hence the tag SG_CA50_20160103.

If regulations change subsequently, tag them accordingly.

** Global Scope: Company

Unless otherwise specified, a Resolution is assumed to belong to a [[*Primary Entity: Company][Company, modeled above]].

** Resolution Types                                                           :SG:SG_CA50_20160103:

If we learn that these resolution types are applicable outside Singapore then update the model accordingly.

*** Directors Resolutions

*** Members Resolutions

**** Ordinary

**** Special

**** Within a Class of Shares
Regulation, articles, or other agreement may specify that shareholders within a certain class may vote as a class on resolutions pertaining to that class of shares.

** Meeting Types

Resolutions may be associated with a Meeting:

*** Directors Meeting

**** Directors Resolutions in Writing

*** Members Meeting

**** AGM

**** EGM

**** Members Resolutions In Writing

** Notices and Filings; Time and Dates

*** Meetings require Notice to the attendees.

*** Meetings produce Minutes.

*** Some minutes must be filed with the state.

*** Some minutes may be filed with the state.

 
** Signatures

** Validity: Quorum

To be valid, a general meeting requires a quorum.

** Validity: Pass / Fail

To pass, a resolution must meet certain voting or signature requirements.

The requirements may differ by subject matter.

* Legalese Katas

These katas pose problems to be solved. They allow us to compare the solutuions proposed by different approaches -- DSLs, different languages, different paradigms.

** Fundraising Tests
see [[file:fundraising-tests.org]] for a test suite

** Kata MD01: Modeling Drafting

In a contract, change every instance of "Articles of Association" to "Constitutional Documents".

** Kata MD02: Conditions Precedent

#+BEGIN_QUOTE
  The obligations of the parties under this Agreement shall be conditional upon the completion of the subscription for the Preference Shares being effected in accordance with the terms of the Investment Agreement.
#+END_QUOTE

** Kata MD03: Conflict Detection

Detect the conflict between 3.1 vs 6.2 of http://legal.cf.sg/purchase_agreement_for_convertible_note/

** Kata MD04: Model the conversion logic described in the [[https://www.ycombinator.com/documents/#seriesaa][YC-AA]] documents
especially the Deemed Issue logic of the [[https://www.ycombinator.com/docs/Series_AA_COI.docx][COI]].

** Kata MD05: antidilution clause

Model this!

#+BEGIN_QUOTE
WHEREAS

(A)Company will apply the following provision(s) to this Agreement, in addition to the shareholder rights defined in the Company Memorandum of Association.

ADDENDUM

NOW, THEREFORE, THE PARTIES HAVE AGREED AS FOLLOWS:

1. ANTI-DILUTION

If the Company issues any additional shares (including, but not limited to, all classes of shares, warrants, rights to subscribe for shares and securities convertible into any share class) for a consideration per share that is less than the Subscription price per share (as adjusted for any change of nominal values of shares, e.g. share splits and similar events), the subscription price (as adjusted for share splits, consolidations of shares and similar events) of the subscribed shares issued subject to this Investment shall be adjusted on a full ratchet basis.
The adjustment will be made through the issuance of additional shares to the Subscriber at par value (i.e. S$1.00 per subscribed share of nominally S$1.00), so that the ownership of the Subscriber after the dilutive issuance shall be set equal to the ownership that the Subscriber would have had if the subscription price paid by the Subscriber (based on the Investment amount, added for the avoidance of doubt, the amount paid to Subscribe for the anti-dilution shares) had been the same as the price of the dilutive issuance.

SIGNED BY AND AMONG:

Company Pte. Limited

Investor
#+END_QUOTE  

** Kata ML01: Modeling Legislation and Regulation

As seen [[*Regulations and Contracts as Business Logic][above]]:

#+BEGIN_QUOTE
Except as specified in paragraph c, you, an establishment that collects blood, must test each donation of human blood that is intended for use in preparing a product for evidence of infection due to the following communicable disease agents:
(1) Human immunodeficiency virus, type 1;
(2) Human T-lymphotropic virus, type I, and
(3) Human T-lymphotropic virus, type II.
#+END_QUOTE

*** Develop a formalism to represent the above text.

*** Compile the formalism to the original English.

**** Readings
http://www.inf.ed.ac.uk/teaching/courses/nlg/

*** Compile the formalism to a specification language.

*** Compile the formalism to a programming language.

*** Compile the formalism to a non-English natural language.

** Kata MR01: Modeling Resolutions

** Securities Notice.

If the Company proposes to undertake an issuance of New Securities, it shall give notice to each Major Shareholder of its intention to issue New Securities (the "Notice") describing the type of New Securities and the price and the general terms upon which the Company proposes to issue the New Securities.


** Right of First Refusal Notice

Subject to any direction to the contrary that may be given by the company in general meeting, all shares, before being offered for transfer to any person who is not a Member, shall first be offered, on the same terms, to such persons as at the date of the offer are entitled to receive notices from the company of general meetings in proportion, as nearly as the circumstances admit, to the amount of the existing shares to which they are entitled, first within their class of shares and then to Members of other classes.

Subject to any direction to the contrary that may be given by the company in general meeting,
  all shares,
    before being offered for transfer to any person who is not a Member,
    shall first be offered, on the same terms, to
      such persons as at the date of the offer are entitled to receive notices from the company of general meetings
    in proportion,
      as nearly as the circumstances admit,
      to the amount of the existing shares to which they are entitled,
    first within their class of shares
    and then to Members of other classes.
  





The offer shall be made via the Directors or the Corporate Secretary by notice specifying the number of shares offered, and limiting a time within which the offer, if not accepted, will be deemed to be declined, and, after the expiration of that time, or on the receipt of an intimation from the person to whom the offer is made that he declines to accept the shares offered, the directors may register the transfer of those shares as directed by the transferor.








Each Major Shareholder will have (10) days from the date of notice, to agree in writing to purchase such Major Shareholder's Pro Rata Share of such New Securities for the price and upon the general terms specified in the Notice by giving written notice to the Company and stating therein the quantity of New Securities to be purchased (not to exceed such Major Shareholder's Pro Rata Share).

* Full Cases

** YC SAFE

*** Conception Clause

Alice will pay ten dollars to Bob.

*** Newborn Clause

The Company means Bob.

Investor means Alice.

The Investor will pay ten dollars to the Company.

The Company will issue to the Investor ten shares of Common Stock.

*** Newborn Birthday Clause

On January 1 2018, the Company will issue to the Investor ten shares of Common Stock.

*** Infant Clause

The Company will issue to the Investor a number of shares of SAFE Preferred Stock equal to the Purchase Amount divided by the SAFE Price.

*** Swaddled Infant

Definitions Section:

Equity Financing means a bona fide transaction or series of transactions with the principal purpose of raising capital, pursuant to which the Company issues and sells shares of preferred stock of the Company at a fixed pre-money valuation.

SAFE Preferred Stock means the shares of a series of the Company’s preferred stock issued to the Investor in an Equity Financing, having the identical rights, privileges, preferences and restrictions as the shares of Standard Preferred Stock, other than with respect to the per share liquidation preference, which will equal the SAFE Price, as well as price-based antidilution protection and dividend rights, which will be based on such SAFE Price.

SAFE Price means the price per share equal to the quotient obtained by dividing the Valuation Cap by either
- the Company Capitalization as of immediately prior to the Equity Financing or
- the capitalization of the Company used to calculate the price per share of the Standard Preferred Stock, whichever calculation results in a lower price.

Standard Preferred Stock means the shares of a series of the Company’s preferred stock issued to the investors investing new money in the Company in connection with the initial closing of the Equity Financing.

*** Swaddled Infant's Mama and Papa

This agreement is between

Party A (the "Investor")

and

Party B (the "Company").

*** Baby Clause, wearing Green

If the pre-money valuation is greater than the Valuation Cap,

  the Company will issue to the Investor a number of shares of SAFE Preferred Stock equal to the Purchase Amount divided by the SAFE Price,

otherwise,

  the Company will issue to the Investor a number of shares of Standard Preferred Stock sold in the Equity Financing equal to the Purchase Amount divided by the price per share of the Standard Preferred Stock

*** Baby Clause, wearing Blue

(this clause is semantically identical to the Green clause, just syntactically refactored.)

The Company will issue to the Investor either:

- a number of shares of Standard Preferred Stock sold in the Equity Financing equal to the Purchase Amount divided by the price per share of the Standard Preferred Stock, if the pre-money valuation is less than or equal to the Valuation Cap; or

- a number of shares of SAFE Preferred Stock equal to the Purchase Amount divided by the SAFE Price, if the pre-money valuation is greater than the Valuation Cap.

*** Toddler Clause

(the clause becomes a callback to be automatically executed, conditional upon an event.)

If there is an Equity Financing before the expiration or termination of this instrument, the Company will automatically issue to the Investor either:

- a number of shares of Standard Preferred Stock sold in the Equity Financing equal to the Purchase Amount divided by the price per share of the Standard Preferred Stock, if the pre-money valuation is less than or equal to the Valuation Cap; or

- a number of shares of SAFE Preferred Stock equal to the Purchase Amount divided by the SAFE Price, if the pre-money valuation is greater than the Valuation Cap.

*** Toddler Twins

If there is an Equity Financing before the expiration or termination of this instrument, the Company will automatically issue to the Investor either:

- a number of shares of Standard Preferred Stock sold in the Equity Financing equal to the Purchase Amount divided by the price per share of the Standard Preferred Stock, if the pre-money valuation is less than or equal to the Valuation Cap; or

- a number of shares of SAFE Preferred Stock equal to the Purchase Amount divided by the SAFE Price, if the pre-money valuation is greater than the Valuation Cap.

In connection with the issuance of Standard Preferred Stock or SAFE Preferred Stock, as applicable, by the Company to the Investor pursuant to this provision:

- The Investor will execute and deliver to the Company all transaction documents related to the Equity Financing; and

- This instrument will expire and terminate.

*** The Complete Equity Financing Clause

If there is an Equity Financing before the expiration or termination of this instrument, the Company will automatically issue to the Investor either:

- a number of shares of Standard Preferred Stock sold in the Equity Financing equal to the Purchase Amount divided by the price per share of the Standard Preferred Stock, if the pre-money valuation is less than or equal to the Valuation Cap; or

- a number of shares of SAFE Preferred Stock equal to the Purchase Amount divided by the SAFE Price, if the pre-money valuation is greater than the Valuation Cap.

In connection with the issuance of Standard Preferred Stock or SAFE Preferred Stock, as applicable, by the Company to the Investor pursuant to this provision:

- The Investor will execute and deliver to the Company all transaction documents related to the Equity Financing; provided, that such transaction documents are the same documents to be entered into with the purchasers of the Standard Preferred Stock, with appropriate variations for the SAFE Preferred Stock if applicable;

- The Investor and the Company will execute a Pro Rata Rights Agreement, unless the Investor is already included in such rights in the transaction documents related to the Equity Financing; and

- This instrument will expire and terminate.

*** Learning to Keep Secrets

Confidentiality. The Investor will not disclose anything about this deal to any third party.

*** Promising to Keep Secrets Forever

Survival. Clause "Confidentialty" will survive the termination of this Agreement.

** YC SAFE (SG)

#+BEGIN_SRC yaml
  # comment: we define the company as an instance of the Company class
  #          or, if you're a functional programmer, as having a Company type
  
  my company is a Company with:
    id: 2016000001A
    name: My Example Inc.
  
  # the syntax looks a lot like YAML. I prefer YAML to JSON because:
  # 1. we have better uses for curly braces.
  # 2. Ingy is a personal friend.
  
  # instead of cryptic punctuation (preferred by Hardcore Computer Scientists)
  # and terse keywords (preferred by Real Programmers),
  # the Legalese DSL is more verbose, more applescripty, because our users are more lay.
  
  
  
  # comment: a safeRound is an instance of the InvestmentFinancingWorkflow class.
  # with prototypal inheritance, other objects could themselves inherit from safeRound.
    
  my safeRound is an InvestmentFinancingWorkflow.
  
  # after introducing a thing by saying "my" or "a", we subsequently refer to it as "the".
  # this is syntactic sugar; think of "my" and "a" as a variable declaration. indeed, perl uses "my"!
  # the my/a variable declaration is responsible for setting the type.
  # 
  # subsequently, we use "the" to refer to a variable that has been declared somewhere above.
  # this is consistent with English grammatical norms.
  # so a layperson reading a fragment which says "the thing" will know to search for "a thing".
  # if code gets moved around so that "the" comes before "a" the compiler will know to throw a type error.
  #
  # "my" establishes a singleton global object.
  # "a" establishes a potentially one-of-many object.
  # "an" is a synonym for "a".
  
  the safeRound has parties:
    investors (each an 'investor'):
      - name: Alice, id: S1111111A, purchaseMoney: US$20000
      - name: Bob,   id: S2222222B, purchaseMoney: US$10000
      - name: Carol (defined above/below)
    company: (defined above/below)
  
  # we infer from above that safeRound.parties.investors is an array of generic objects
  # we infer that each of those objects has attributes name,id,purchaseMoney
  # each of which has their own inferred types.
  # Idris would be really strong at inferring dependent types.
  
  # the above stanza also introduces the parenthetical remark.
  # Like most languages, parentheses are used for argument-passing to function calls and method calls.
  # Parentheses are also used for expression grouping.
  # Unlike most languages, Legalese uses parentheses following a symbol as a compiler hint and/or as an expression that appears in the output text.
  # Single quotes are used to identify a symbol in much the same way that Prolog uses them.
  # If an array is hinted with "(each a 'thingy')" then whenever we iterate through that array,
  # Legalese automatically binds 'thingy' as the loop variable.
  
  
  # next comes an example of defining an investor separately.
  # note that it is linked in to the safeRound.parties.investors array.
  # how is that done?
  # the (defined above/below) token instructs the compiler to expect to find an investor with "name: Carol" elsewhere in the program.
  # later, when "a particular investor has" the name Carol, that is unified into safeRound.parties.investors due to matching type and name.
  
  a particular investor has:
    name: Carol
    id: S3333333C
    purchaseMoney: US$5000
  
  # comment: we define a safeInstrument as a specific document signed between the investors and the company.
  # we could also have worded this as "and all of" or "and any of" or just the thing.
  # safeInstrument is an instance/subclass of Security, which would normally be defined in a library separately.
  
  a safeInstrument defines a Security relation between company and each of safeRound.parties.investors.
  
  # under the hood, this creates a cartesian product of the 1 or more arrays specified. there is some subtlety here.
  
  # you actually get a generator named safeInstrument, which is iterable.
  # for the sake of illustration you can imagine that we are dealing with something kind of like:
  #   safeInstruments = [ safeInstrument1, ..., safeInstrumentn ]
  #   safeInstrument1.company = company
  #   safeInstrument1.investor = Alice
  #   safeInstrument2.company = company
  #   safeInstrument2.investor = Bob
  #   safeInstrument3.company = company
  #   safeInstrument3.investor = Carol
  
  # what is the subtlety? if we had said
  # a safeInstrument defines a Security relation between company and all of safeRound.parties.investors.
  # or the identical
  # a safeInstrument defines a Security relation between company and        safeRound.parties.investors.
  #
  # then we would have a single safeInstrument with
  # safeInstrument.company = company
  # safeInstrument.investors = [ Alice, Bob, Carol ]
  
  # if we had said
  # a safeInstrument defines a Security relation between company and any of safeRound.parties.investors.
  # then the moment any of the investors signs the document, the relation is considered satisfied.
  # when might we want to do that? maybe when any one of N directors has previously been authorized to sign something.
  
  # if you are already a bad-ass Haskell programmer these ideas will come very naturally to you:
  # cartProd xs ys = [(x,y) | x <- xs, y <- ys]
  
  
  
  
  # next we come to objects and pattern-matching on attributes.
  
  # comment: saying "a Thing generally has Blah" is syntactic sugar for establishing Thing.Blah as itself an object with its own attributes.
  
  the safeInstrument generally has terms:
    discount:  0.2
    valuation: 100000
    maturity:  3y
  
  # safeInstrument.terms = { discount: 0.2, valuation: 10000, maturity: 3y }
  #    or, spelling it out,
  # safeInstrument.terms.discount = 0.2
  # safeInstrument.terms.valuation = 100000
  # safeInstrument.terms.maturity = 3y
  
  the safeInstrument generally also has:
    agreementDate: 2016-02-30 is a Date
    effectiveDate: {{ .investor.date || today() }}
  
  # if a thing is enclosed in double curly braces, that means it is an expression meant to be executed at compile time.
  # the "investor" symbol is available to the safeInstrument because the relation is defined between company and safeRound.parties.investors, each of which was defined earlier to be 'investor'.
  # note that there are two paths to the 'company' symbol -- global scope and object scope. both point to the same actual company.
  # in this case the object is the safeInstrument.
  # the safeInstrument has an attribute 'investor'. so that's how that gets there.
  # what does a dot prefix mean? it's syntactic sugar, or rather syntactic aspartame, for "this.".
  
  # Legalese has two implicit context variables: . and _.
  #  the .  prefix means "this.". The "this" comes from the containing contex.t
  #  the _. prefix is the loop variable in a list comprehension, like array.all( print _.name ). It's like perl's $_ in that situation.
  
  
  # notice how we've been saying "the Thingy generally has"?
  # that means that a Thingy with a specific set of properties may be dealt with differently.
  # this is kind of like your basic prolog/erlang-style pattern-matching, or like Haskell's guards:
  
  the SafeInstrument generally has:
    explode: one doc per investor
  
  a SafeInstrument (locale:"en-UK") has:
    explode: one doc for all parties
  
  # is that prototypal inheritance? Why, I suppose it is.
  
  the SafeInstrument generally has:
    parts: [ intro, topDefinitions, events, conditionsPrecedent, definitions, representationsCompany, representationsInvestor, miscellaneous, attestation]
    intro: {
      "this document" certifies {
        consideration({from: investor, to: company}) ->
        company.hereby( issues( rightTo( shares( subjectTo( terms ) ) ) ) ) )
    }
    topDefinitions: company.terms.FILTER(discount,valuation,maturity)
    # whoa, what's the difference between object.filter() and object.FILTER()?
    # uppercase methods and functions run at compile time!
    # lowercase methods and functions represent contractual intent and are translated for output.
    # it's like the difference between #ifdef and if().
  
    # check it out, Legalese supports reactive programming.
    # An object can define an "events" dictionary, which registers a set of "upon" handlers.
    # Legalese makes it easy to call all "upon" handlers against a scenario.
    events:
      - upon(company.event.financing.equityIssue ('equityIssue')) {
          # check it out, Legalese supports deontic modal logic.
          # the special method .must() on an object registers an obligation for our mu-calculus engine to reason about.
          # syntax: object.must(conditions) { body }
          company.must(automatically) {
            safe.parties.investors.all(
              company.must(upon(equityIssue.stage=="completion")) {
                .issue(equityIssue.shareClass, quantity:investor.purchaseMoney / equityIssue.pricePerShare)
                .to(investor) ('ShareIssue')
              }
            )
          }
  
          # check it out, Legalese supports the definition of "variables" which are really functors.
          # the text output engine is responsible for optimizing these definitions into comprehensible natural language.
          defining safe.parties.investors.all( _.EFdocs = equityIssue.transactionDocuments.filter.hasParty(_) )
          defining EFpurchasers = equityIssue.purchasers
  
          # parentheticals may prefix or suffix any expression.
          # sometimes they serve no semantic function, only a narrative function.
          (inConnectionWith(ShareIssue))
          investor.must(.EFdocs.all(_.parties.any(|p| EFpurchasers.any(_ == p)))
                        and
                        (.EFdocs.all(_.has(dragAlongRights) and
                                     _.dragAlongRights.applyTo(investor) and
                                     _.has(dragAlongRights.exceptions) ('dragE') and
                                     dragE.any.applyTo(investor)))): {
            .EFdocs.all(.execute(_) and .deliver(_).to(company))
          }
          # that last bit was kinda dense but it can't be helped;
          # when the CS formalizations are as cryptic as the legal-latin incantations, we know we're dealing in the same order of complexity.
  
          (investor & company).must( unless investor.EFdocs.any(_.has(proRataRights) and
                                                                _.proRataRights.applyTo(investor))) {
            .execute(new proRataRightsAgreement)
          }
        }    
  
        - upon(company.event.liquidity ('liquidityEvent')) {
  
          investor.may( # missing a notice period deadline here
          ) { choose any one .liquidityPayout from [ cashPayout, speciePayout ] }
          else { .liquidityPayout = speciePayout }
  
          company.may( liquidityEvent.status=="preconsummation") else
          company.must(liquidityEvent.status==   "consummation") {
            var cashPaid = {
              if (investor.liquidityPayout == cashPayout) {
                defining 'Cash-Out Investors' = safeRound.parties.investors.filter(_.liquidityPayout == cashPayout)
                var origCashPayable = 'Cash-Out Investors'.sum(_.moneyAmount)
    
                company.board.may(liquidityEvent by_virtue_of company.event.changeOfControl
                                  and
                                  company.event.changeOfControl.intentions.include(
                                  "to qualify as a tax-free reorganization for U.S. federal income tax purposes")) {
                  var reducedPaymentAmount = origCashPayable - company.board.resolution(reducePaymentBy)
                  # this is the I/O problem of pure functional languages
                                  }
                                  
                var cashPayableAggregate  = reducedPaymentAmount or origCashPayable
                val cashPayment = proRataPayment(investor, 'Cash-Out Investors',purchaseMoney,
                                                 cashPayableAggregate,company.fundsAvailable)
                company.pay(cashPayment).to(investor)
              }
              else { 0 }
            }
            company.issue(company.stock.common,
                          quantity:(investor.purchaseMoney - cashPaid) / liquidityEvent.pricePerShare)
          }
          
        - upon(company.event.dissolution ('dissolutionEvent')) {
            company.must() {
              val cashPayment = proRataPayment(investor, safeRound.parties.investors, purchaseMoney,
                                               safeRound.parties.investors.sum(purchaseMoney),
                                               company.fundsAvailable)
              company.pay(cashPayment).to(investor)
            }
          }
  
  // define somePreferredStock as being named Standard or Safe Preferred Stock depending on the situation
  
  function _proRata(i,is,key) { i[key] / is.sum(_[key]) }
  
  function proRataPayment(individual, all, key, desiredAmount, fundsAvailable) {
    return desiredAmount * _proRata(individual,all,key) * ((fundsAvailable >= desiredAmount) ? 1 : fundsAvailable / desiredAmount)
  }
  
  # comment: the definitions of Security, Agreement, Document, etc would normally live in separate library modules
  # but we display them here for completeness, so you can see the object model
    
  a Security is an Agreement.
  
  a Security generally has:
    term: is a DateInterval
    terminationDate: is a Date {
      .effectiveDate + .term
    }
  
  # comment: we define Agreement
    
  an Agreement generally has:
    effectiveDate: is a Date
    parties.company: is a Company
  
  an Agreement is a Document.
  
  # commen: we define Document
  
  a Document generally has:
    locale: is a String
    name: is a String
    templateUrl: is a URL
    version: is a String
    
    
  
#+END_SRC

#+BEGIN_SRC
moo
#+END_SRC
